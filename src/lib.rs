// Copyright 2022 Contributors to the Veraison project.
// SPDX-License-Identifier: Apache-2.0

#[derive(thiserror::Error, PartialEq, Eq)]
pub enum Error {
    #[error("configuration error: {0}")]
    ConfigError(String),
    #[error("API error: {0}")]
    ApiError(String),
    #[error("callback error: {0}")]
    CallbackError(String),
    #[error("feature not implemented: {0}")]
    NotImplementedError(String),
}

// While for other error sources the mapping may be more subtle, all reqwest
// errors are bottled as ApiErrors.
impl From<reqwest::Error> for Error {
    fn from(re: reqwest::Error) -> Self {
        Error::ApiError(re.to_string())
    }
}

impl std::fmt::Debug for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::NotImplementedError(e)
            | Error::ConfigError(e)
            | Error::ApiError(e)
            | Error::CallbackError(e) => {
                write!(f, "{}", e)
            }
        }
    }
}

/// EvidenceCreationCb is the function signature of the application callback.
/// The application is passed the session nonce and the list of supported
/// evidence media types and shall return the computed evidence together with
/// the selected media type.
type EvidenceCreationCb = fn(nonce: &[u8], accepted: &[String]) -> Result<(Vec<u8>, String), Error>;

/// A builder for ChallengeResponse objects
pub struct ChallengeResponseBuilder {
    base_url: Option<String>,
    // TODO(tho) add TLS config / authn tokens etc.
}

impl ChallengeResponseBuilder {
    /// default constructor
    pub fn new() -> Self {
        Self { base_url: None }
    }

    /// Use this method to supply the base URL of the service implementing the
    /// challenge-response API.  E.g.,
    /// "https://veraison.example/challenge-response/v1/".
    pub fn with_base_url(mut self, v: String) -> ChallengeResponseBuilder {
        self.base_url = Some(v);
        self
    }

    /// Instantiate a valid ChallengeResponse object, or fail with an error.
    pub fn build(self) -> Result<ChallengeResponse, Error> {
        let base_url_str = self
            .base_url
            .ok_or_else(|| Error::ConfigError("missing API endpoint".to_string()))?;

        Ok(ChallengeResponse {
            base_url: url::Url::parse(&base_url_str)
                .map_err(|e| Error::ConfigError(e.to_string()))?,
            http_client: reqwest::blocking::Client::builder().build()?,
        })
    }
}

impl Default for ChallengeResponseBuilder {
    fn default() -> Self {
        Self::new()
    }
}

/// The object on which one or more challenge-response verification sessions can
/// be run.  Always use the [ChallengeResponseBuilder] to instantiate it.
pub struct ChallengeResponse {
    base_url: url::Url,
    http_client: reqwest::blocking::Client,
}

/// Nonce configuration: either the size (Size) of the nonce generated by the
/// server (use 0 to let the server also pick the size of the challenge), or an
/// explicit nonce (Value) supplied as a byte array.
pub enum Nonce {
    Size(usize),
    Value(Vec<u8>),
}

impl ChallengeResponse {
    /// Run a challenge-response verification session using the supplied nonce
    /// configuration and evidence creation callback. Returns the raw attestation results, or an
    /// error on failure.
    pub fn run(
        &self,
        nonce: Nonce,
        evidence_creation_cb: EvidenceCreationCb,
    ) -> Result<String, Error> {
        // create new c/r verification session on the veraison side
        let (session_url, session) = self.new_session(&nonce)?;

        // invoke the user-provided evidence builder callback with per-session parameters
        let (evidence, media_type) = (evidence_creation_cb)(session.nonce(), session.accept())?;

        // send evidence for verification to the session endpoint
        let attestation_result = self.challenge_response(&evidence, &media_type, &session_url)?;

        // return veraison's attestation results
        Ok(attestation_result)
    }

    /// Ask Veraison to create a new challenge/response session using the supplied nonce
    /// configuration. On success, the return value is a tuple of the session URL for subsequent
    /// operations, plus the session data including the nonce and the list of accept types.
    pub fn new_session(&self, nonce: &Nonce) -> Result<(String, ChallengeResponseSession), Error> {
        // ask veraison for a new session object
        let resp = self.new_session_request(nonce)?;

        // expect 201 and a Location header containing the URI of the newly
        // allocated session
        match resp.status() {
            reqwest::StatusCode::CREATED => (),
            status => {
                // on error the body is a RFC7807 problem detail
                //
                // NOTE(tho) -- this assumption does not hold in general because
                // the request may be intercepted (and dealt with) by HTTP
                // middleware that is unaware of the API.  We need something
                // more robust here that dispatches based on the Content-Type
                // header.
                let pd: ProblemDetails = resp.json()?;

                return Err(Error::ApiError(format!(
                    "newSession response has unexpected status: {}.  Details: {}",
                    status, pd.detail
                )));
            }
        };

        // extract location header
        let loc = resp
            .headers()
            .get("location")
            .ok_or_else(|| {
                Error::ApiError("cannot determine URI of the session resource".to_string())
            })?
            .to_str()
            .map_err(|e| Error::ApiError(e.to_string()))?;

        // join relative location with base URI
        let session_url = resp
            .url()
            .join(loc)
            .map_err(|e| Error::ApiError(e.to_string()))?;

        // decode returned session object
        let crs: ChallengeResponseSession = resp.json()?;

        Ok((session_url.to_string(), crs))
    }

    /// Execute a challenge/response operation with the given evidence.
    pub fn challenge_response(
        &self,
        evidence: &[u8],
        media_type: &str,
        session_url: &str,
    ) -> Result<String, Error> {
        let c = &self.http_client;

        let resp = c
            .post(session_url)
            .header(reqwest::header::ACCEPT, CRS_MEDIA_TYPE)
            .header(reqwest::header::CONTENT_TYPE, media_type)
            .body(evidence.to_owned())
            .send()?;

        let status = resp.status();

        if status.is_success() {
            match status {
                reqwest::StatusCode::OK => {
                    let crs: ChallengeResponseSession = resp.json()?;

                    if crs.status != "complete" {
                        return Err(Error::ApiError(format!(
                            "unexpected session state: {}",
                            crs.status
                        )));
                    }

                    let result = crs.result.ok_or_else(|| {
                        Error::ApiError(
                            "no attestation results found in completed session".to_string(),
                        )
                    })?;

                    Ok(result)
                }
                reqwest::StatusCode::ACCEPTED => {
                    // TODO(tho)
                    Err(Error::NotImplementedError("asynchronous model".to_string()))
                }
                status => Err(Error::ApiError(format!(
                    "session response has unexpected success status: {}",
                    status,
                ))),
            }
        } else {
            let pd: ProblemDetails = resp.json()?;

            Err(Error::ApiError(format!(
                "session response has error status: {}.  Details: {}",
                status, pd.detail,
            )))
        }
    }

    fn new_session_request(&self, nonce: &Nonce) -> Result<reqwest::blocking::Response, Error> {
        let u = self.new_session_request_url(nonce)?;

        let r = self
            .http_client
            .post(u.as_str())
            .header(reqwest::header::ACCEPT, CRS_MEDIA_TYPE)
            .send()?;

        Ok(r)
    }

    fn new_session_request_url(&self, nonce: &Nonce) -> Result<url::Url, Error> {
        let base = &self.base_url;

        let mut new_session_url = base
            .join("newSession")
            .map_err(|e| Error::ConfigError(e.to_string()))?;

        let mut q_params = String::new();

        match nonce {
            Nonce::Value(val) if !val.is_empty() => {
                q_params.push_str("nonce=");
                q_params.push_str(&base64::encode_config(val, base64::URL_SAFE));
            }
            Nonce::Size(val) if *val > 0 => {
                q_params.push_str("nonceSize=");
                q_params.push_str(&val.to_string());
            }
            _ => {}
        }

        new_session_url.set_query(Some(&q_params));

        Ok(new_session_url)
    }
}

const CRS_MEDIA_TYPE: &str = "application/vnd.veraison.challenge-response-session+json";

#[serde_with::serde_as]
#[serde_with::skip_serializing_none]
#[derive(serde::Deserialize, serde::Serialize)]
pub struct ChallengeResponseSession {
    #[serde_as(as = "serde_with::base64::Base64")]
    nonce: Vec<u8>,
    #[serde_as(as = "chrono::DateTime<chrono::Utc>")]
    expiry: chrono::NaiveDateTime,
    accept: Vec<String>,
    status: String,
    evidence: Option<EvidenceBlob>,
    result: Option<String>,
}

impl ChallengeResponseSession {
    pub fn nonce(&self) -> &[u8] {
        &self.nonce
    }

    pub fn accept(&self) -> &[String] {
        &self.accept
    }
}

#[serde_with::serde_as]
#[derive(serde::Deserialize, serde::Serialize)]
pub struct EvidenceBlob {
    r#type: String,
    #[serde_as(as = "serde_with::base64::Base64")]
    value: Vec<u8>,
}

#[derive(serde::Deserialize)]
struct ProblemDetails {
    r#type: String,
    title: String,
    status: u16,
    detail: String,
}

#[cfg(test)]
mod tests {
    use super::*;
    use wiremock::matchers::{method, path};
    use wiremock::{Mock, MockServer, ResponseTemplate};

    const TEST_BASE_URL_OK: &str = "https://veraison.example/challenge-response/v1/";
    const TEST_BASE_URL_NOT_ABSOLUTE: &str = "/challenge-response/v1/";

    #[test]
    fn default_constructor() {
        let b: ChallengeResponseBuilder = Default::default();

        // expected initial state
        assert!(b.base_url.is_none());
    }

    #[test]
    fn build_ok() {
        let b = ChallengeResponseBuilder::new().with_base_url(TEST_BASE_URL_OK.to_string());

        assert!(b.build().is_ok());
    }

    #[test]
    fn build_fail_base_url_not_absolute() {
        let b =
            ChallengeResponseBuilder::new().with_base_url(TEST_BASE_URL_NOT_ABSOLUTE.to_string());

        assert!(b.build().is_err());
    }

    #[test]
    fn build_fail_missing_base_url() {
        let b = ChallengeResponseBuilder::new();

        assert!(b.build().is_err());
    }

    #[test]
    fn build_fail_missing_evidence_creation_cb() {
        let b =
            ChallengeResponseBuilder::new().with_base_url(TEST_BASE_URL_NOT_ABSOLUTE.to_string());

        assert!(b.build().is_err());
    }

    #[async_std::test]
    async fn new_session_request_ok() {
        let mock_server = MockServer::start().await;
        let nonce_value = vec![0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef];
        let nonce = Nonce::Value(nonce_value.clone());

        let response = ResponseTemplate::new(201)
            .insert_header("location", "1234")
            .set_body_json(ChallengeResponseSession {
                nonce: nonce_value,
                status: "waiting".to_string(),
                accept: vec!["application/vnd.1".to_string()],
                evidence: None,
                result: None,
                expiry: chrono::Utc::now().naive_utc(),
            });

        Mock::given(method("POST"))
            .and(path("/newSession"))
            .respond_with(response)
            .mount(&mock_server)
            .await;

        let cr = ChallengeResponseBuilder::new()
            .with_base_url(mock_server.uri())
            .build()
            .unwrap();

        let rv = cr.new_session(&nonce).expect("unexpected failure");

        // Expect we are given the expected location URL
        assert_eq!(rv.0, format!("{}/1234", mock_server.uri()));
    }

    #[async_std::test]
    async fn challenge_response_ok() {
        let mock_server = MockServer::start().await;
        let nonce_value = vec![0xbe, 0xef];
        let evidence_value: Vec<u8> = vec![0, 1];
        let evidence = EvidenceBlob {
            r#type: "application/vnd.1".to_string(),
            value: evidence_value.clone(),
        };
        let attestation_result = "a.b.c".to_string();

        let response = ResponseTemplate::new(200).set_body_json(ChallengeResponseSession {
            nonce: nonce_value,
            status: "complete".to_string(),
            accept: vec!["application/vnd.1".to_string()],
            evidence: Some(evidence),
            result: Some(attestation_result.clone()),
            expiry: chrono::Utc::now().naive_utc(),
        });

        Mock::given(method("POST"))
            .and(path("/session/5678"))
            .respond_with(response)
            .mount(&mock_server)
            .await;

        let cr = ChallengeResponseBuilder::new()
            .with_base_url(mock_server.uri())
            .build()
            .unwrap();

        let session_url = mock_server.uri() + "/session/5678";
        let media_type = "application/vnd.1";

        let rv = cr
            .challenge_response(&evidence_value, media_type, &session_url)
            .expect("unexpected failure");

        // Expect we are given the expected attestation result
        assert_eq!(rv, attestation_result)
    }
}
